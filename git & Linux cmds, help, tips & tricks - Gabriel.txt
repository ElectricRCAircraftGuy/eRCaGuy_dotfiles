
Gabriel Staples

This file is part of eRCaGuy_dotfiles: https://github.com/ElectricRCAircraftGuy/eRCaGuy_dotfiles


====================================================================================================
= Doxygen: = 
====================================================================================================

See other examples here:
1. http://www.doxygen.nl/manual/commands.html
1. https://stackoverflow.com/questions/15398711/whats-the-right-way-to-reference-a-parameter-in-doxygen/56745246#56745246
1. https://stackoverflow.com/questions/34196663/stm32-how-to-get-last-reset-status/54728664#54728664
1. https://stackoverflow.com/questions/385975/error-handling-in-c-code/59221452#59221452

Here's a bunch of Doxygen examples for easy copy/pasting into your code when you are frequently writing Doxygen:

Full Doxygen function header example:

    /// \brief          A brief one or two line description of the function.
    /// \note           An important note the user should be aware of--perhaps many lines.
    /// \details        Extra details.
    ///                 Perhaps
    ///                 even
    ///                 a long
    ///                 paragraph.
    /// \param[in]      var1            Description of variable one, an input
    /// \param[in]      my_longer_var2  Description of variable two, an input
    /// \param[out]     var3            Description of variable three, an output (usu. via a pointer
    ///                                 to a variable)
    /// \param[in,out]  var4            Description of variable four, an input/output (usu. via a
    ///                                 pointer) since its initial value is read and used, but then 
    ///                                 it is also updated by the function at some point
    /// \return         Description of return types. It may be an enum, with these
    ///                 possible values:
    ///                 - #ENUM_VALUE_1
    ///                 - #ENUM_VALUE_2
    ///                 - #ENUM_VALUE_3
    my_enum_t myFunc(int var1, int var2, int* var3, int* var4)
    {
        // function implementation here
        
        my_enum_t error = ENUM_VALUE_1;
        
        // Check for NULL pointers
        if (!var3 || !var4)
        {
            // var3 or var4 are NULL pointers, which means they can't be dereferenced
            error = ENUM_VALUE_2;
            goto done;
        }

        if (something_else)
        {
            error = ENUM_VALUE_3;
            goto done;
        }

    done:
        return error;
    }

You may also use `@` instead of `\`:

    /// @brief          A brief one or two line description of the function.
    /// @param[in]      var1            Description of variable one, an input
    /// @param[in]      my_longer_var2  Description of variable two, an input
    /// @param[out]     var3            Description of variable three, an output (usu. via a pointer
    ///                                 to a variable)
    /// @param[in,out]  var4            Description of variable four, an input/output (usu. via a
    ///                                 pointer) since its initial value is read and used, but then 
    ///                                 it is also updated by the function at some point
    /// @return         None
    void myFunc(int var1, int var2, int* var3, int* var4)
    {
        // function implementation here
    }

And here's this shorter version again now with `\` again instead of `@`:

    /// \brief          A brief one or two line description of the function.
    /// \param[in]      var1            Description of variable one, an input
    /// \param[in]      my_longer_var2  Description of variable two, an input
    /// \param[out]     var3            Description of variable three, an output (usu. via a pointer
    ///                                 to a variable)
    /// \param[in,out]  var4            Description of variable four, an input/output (usu. via a
    ///                                 pointer) since its initial value is read and used, but then 
    ///                                 it is also updated by the function at some point
    /// \return         None
    void myFunc(int var1, int var2, int* var3, int* var4)
    {
        // function implementation here
    }

And the more compact version of the above (assumes shorter parameter names, and only [in] or [out] params but no [in,out] params):

    /// \brief      A brief one or two line description of the function.
    /// \param[in]  variable_1  Input parameter
    /// \param[in]  variable_2  Another input parameter
    /// \param[out] variable_3  Output parameter
    /// \param[out] variable_4  Another output parameter
    /// \return     None
    void myFunc(int var1, int var2, int* var3, int* var4)
    {
        // function implementation here
    }


====================================================================================================
= bazel: =
====================================================================================================

Good example to get started in Bazel: https://github.com/ElectricRCAircraftGuy/eRCaGuy_gtest_practice

Config files:
1. BUILD (deprecated)
1. BUILD.bazel (new)
1. WORKSPACE
1. .bazelrc in your workspace directory (next to the main WORKSPACE file); see: https://docs.bazel.build/versions/master/guide.html#where-are-the-bazelrc-files

Bazel Online Documentation:
1. See all Bazel commands here (ie: `bazel --[startup options] <cmd> --[cmd options]`): https://docs.bazel.build/versions/master/command-line-reference.html#commands
2. See all Bazel options online here! https://docs.bazel.build/versions/master/command-line-reference.html. Ex:
    1. To pass in Java Virtual Machine (JVM) options, such as heap size, as Bazel startup options: https://docs.bazel.build/versions/master/command-line-reference.html#flag--host_jvm_args
        --host_jvm_args=<jvm_arg>
    2. To limit how many of your local CPUs Bazel can use. Note that HOST_CPUS here is probably (and usually is) 1/2 the number of cores you have. So, if gnome-system-monitor shows you have 8 cores, you may only have 4 CPUs.: https://docs.bazel.build/versions/master/command-line-reference.html#flag--local_cpu_resources
        --local_cpu_resources=<an integer, or "HOST_CPUS", optionally followed by [-|*]<float>.> default: "HOST_CPUS"
        NB: THIS cpu resource limiter option above doesn't actually work very well! Frequently, even with it in-use, the CPU usage will still lock out at 100% for periods of many minutes at a time! To prevent this, just use the Linux `cpulimit` program in a separate terminal!:
            cpulimit -p <pid> -l 500 # limit your bazel build to 62.5% max CPU usage on an 8-core machine
        Read more about the above command in the "Limit CPU usage" section of this document down below.
    3. To limit local RAM usage: https://docs.bazel.build/versions/master/command-line-reference.html#flag--local_ram_resources
         --local_ram_resources=<an integer, or "HOST_RAM", optionally followed by [-|*]<float>.> default: "HOST_RAM*.67"
    4. To disable remote caching: https://docs.bazel.build/versions/master/command-line-reference.html#flag--remote_cache
        --remote_cache=""
3. "A user's guide to Bazel" - https://docs.bazel.build/versions/master/guide.html

time bazel build //...
time bazel query //...
time bazel test //...
bazel --version
bazel help
bazel help build

bazel --host_jvm_args=-Xmx16g build //... = set max java heap size to 16g then build everything; see: https://stackoverflow.com/questions/55190272/java-lang-outofmemoryerror-when-running-bazel-build/60572662#60572662

*****BEST BAZEL BUILD CMD*****
time bazel --host_jvm_args=-Xmx16g build //...; gs_alert = same as above but better: time the whole thing and do an alert sound (bell character sound) & pop-up notification to notify me when done

bazel test --test_output errors //... = log all errors (failed test results) to stdout; see: https://groups.google.com/forum/#!topic/bazel-discuss/2mJPklIaCeo; see also: `bazel help test` for other options!
bazel test --test_output summary //... = the default (doesn't show errors; just shows a summary)
bazel test --test_output all //... = prints ALL output to stdout, even for tests that pass!

*****BEST BAZEL TEST CMD (optionally add `--host_jvm_args=-Xmx16g` if needed too)*****
time bazel test --test_output=errors --test_arg=--gtest_color=yes //... = get color output in the tests! See the readme in my project here for more explanation and a list of references: https://github.com/ElectricRCAircraftGuy/eRCaGuy_gtest_practice. See also: https://stackoverflow.com/questions/50877601/how-to-pass-custom-flags-to-bazel-test-command/50890446#50890446.


====================================================================================================
= linter, clang-format: = 
====================================================================================================

== clang-format: ==

A source code automatic style formatting tool.

References:
1. Main documentation, setup, instructions, etc! https://clang.llvm.org/docs/ClangFormat.html
2. Download the Windows & other installers/executables: https://llvm.org/builds/
3. Clang-Format Style Options: https://clang.llvm.org/docs/ClangFormatStyleOptions.html

Install in Ubuntu with `sudo apt install clang-format`; source (note I also have an answer here): https://stackoverflow.com/questions/20756924/how-can-i-install-clang-format-in-ubuntu

Help:
    clang-format --help
    man clang-format

To generate a .clang-format file as a starting point:
-See: https://clang.llvm.org/docs/ClangFormat.html
    clang-format --style=llvm --dump-config > .clang-format
    OR
    clang-format --style=google --dump-config > .clang-format

Main clang-format tools & commands include:
    clang-format [options] [<file> ...] = the main command; see: https://clang.llvm.org/docs/ClangFormat.html
    
    clang-format-diff = a python script that allows you to format a git diff patch; see: https://clang.llvm.org/docs/ClangFormat.html
    
    git clang-format = a tool blended in with git to allow you to format just the lines you touched before you git commit them [GS: I don't like this work-flow; I'd rather do a commit and THEN go back and run a command to format *the entire file* for any file I touched, instead. Then, I'll make that format run a separate commit.]

Example usages:
    clang-format --style=google my_file.cpp > my_file_formatted.cpp = format a file and send the output to a separate file, using a preconfigured style
    clang-format -i --style=google my_file.cpp = format this file in-place!
  Use `--verbose` to also print the file names processed!
    clang-format -i --verbose --style=google my_file.cpp = same as above, but print the name of the file processed (particularly useful when you have a script which processes many files and you want the user to see as output a list of the files processed!)
  Use `--style=file` to "load style configuration from .clang-format file located in one of the parent directories of the source file (or current directory for stdin)".
    clang-format --verbose -i --style=file my_file.cpp = format my_file.cpp in place, using the .clang-format file located in one of the parent directories of the source file, printing the name(s) of the file(s) processed. <======= BEST OPTION FOR MANUALLY-SPECIFIED FILE(S)! =======

Whenever I do a `git commit`, however, I'd like to format *all parts of all files I have touched*. To do this, you can see which files were changed between two commits like this:
    git diff --name-only commit1~..commit2  # Note that the tilde (~) is required to specify the commit *before* commit1, because otherwise commit1 would *not* be included in determining which files were changed.
Then you can manually clang-format all of those files, OR (I think--needs to be tested), you can automate the process like this:
    clang-format --verbose -i --style=file $(git diff --name-only commit1~..commit2)  <======= NEEDS TO BE TESTED, BUT SHOULD BE THE BEST OPTION FOR AUTOMATICALLY-SPECIFIED FILES! ======

== clang-tidy: ==

A source code static analysis (programming errors, style, best practices, bug checker) tool.

References:
1. https://clang.llvm.org/extra/clang-tidy/ 


====================================================================================================
= tmux: = 
====================================================================================================

EXCELLENT how-to video! https://www.youtube.com/watch?time_continue=5&v=BHhA_ZKjyxo&feature=emb_logo
EXCELLENT SHORTCUTS & CHEAT-SHEET!: https://gist.github.com/MohamedAlaa/2961058  <=========

tmux = create a new tmux session
tmux new = same as `tmux`
tmux new -s <session_name> = create a new tmux session called "session_name"
tmux ls = list open tmux sessions
tmux list-sessions = same as `tmux ls`!
tmux attach -t <session_num> = re-attach back to 't'arget session session_num!   <===== ATTACH!
tmux a -t <session_num> = same as above ("a" is an alias for "attach")
tmux a = attach the only available session (assuming only one is available) <======= MY MOST COMMON USAGE!
tmux kill-session -t <session_name_or_num> = kill this session! (or, you can just attach to it then type `exit` repeatedly until it's all exited/killed)
tmux rename-session [-t current_name] [new_name] = rename a tmux session! See: https://superuser.com/questions/428016/how-do-i-rename-a-session-in-tmux/428025#428025 

exit = exit the window

Ctrl + B, then <cmd> = have tmux run <cmd>:  <=======
== LIST OF CMDS: ==
:<manual_cmd> = run <manual_cmd>
:split-window = do horizontal split (same as " below!)
=== Windows: ===
c = create window
, = rename window
p = previous window
n = next window
w = list windows
=== Panes (splits): ===
% = vertical split
" = horizontal split
o = swap panes [ie: change from one pane to another, within the same window]
x = kill pane
=== Sessions: ===
d = detach session (leaving it running on the server)!                                  <===== DETACH!
$ = rename current session


====================================================================================================
= git: = 
====================================================================================================

git branch -a = show ALL branches, even remote-only branches
git branch -r = show ONLY 'r'emote branches
git branch -r | grep gabriel.staples = show all of my remote branches (which, by my convention, begin with "gabriel.staples_")
git branch -d -r origin/mybranch = delete remote branch; see: https://stackoverflow.com/questions/5094293/git-remote-branch-deleted-but-still-it-appears-in-branch-a/5096739#5096739
git branch -rd origin/mybranch = same as above

git diff --name-only commit_hash = only see a list of changed files by filename
git diff --name-status commit_hash = [MUCH MORE USEFUL THAN THE CMD ABOVE!] see a list of filenames and status! Ex: indicators for modified, deleted, added, etc.

git merge-base branch1 branch2 = find the common ancestor between branch1 and branch2; see: https://stackoverflow.com/questions/1549146/git-find-the-most-recent-common-ancestor-of-two-branches/1549155#1549155

Assuming you just did this to rebase your feature branch onto latest master:
    git checkout master
    git pull origin master
    git checkout my_branch
    git rebase master  # or `git rebase -i master` to do it interactively
THEN HERE'S HOW TO COMPARE A JUST-REBASED BRANCH (`my_branch`) TO ITS OLD BACKUP (`my_brank_BAK`) FROM BEFORE REBASING:
(Assuming you're still on the newly-rebased branch `my_branch`):
    git difftool my_branch_BAK $(git diff --name-only $(git merge-base my_branch_BAK master) my_branch_BAK) = description: the inner-most $() finds the merge-base between the backup branch and the old master, and the outer $() finds the *list of filenames* which changed from that merge-base to the backup branch. This way, we end up `difftool`ing between the backup branch and the rebased branch, ONLY LOOKING AT THE FILES WE KNOW WE HAD PREVIOUSLY CHANGED!
  Better (easier to read):
    BRANCH_BAK=my_branch_bak && git difftool $BRANCH_BAK $(git diff --name-only $(git merge-base $BRANCH_BAK master) $BRANCH_BAK) <======= QUICKLY CHECK NEWLY-REBASED BRANCH AGAINST ITS BACKUP BRANCH! ======= [be sure to change `master` near the end to whatever upstream you have if necessary too!] <=======
  OR, if you're not on the newly-rebased `my_branch` anymore:
    git difftool my_branch_BAK..my_branch $(git diff --name-only $(git merge-base my_branch_BAK master) my_branch_BAK)

man git commit
git commit --date "Wed Jan 01 23:00:00 2020 -0700"
    - See `git log` for what various date formats look like

git push origin my_local_branchname:my_remote_branchname = push my_local_branchname to origin/my_remote_branchname; normally `git push`ing only allows pushing to a remote branch of the *same* branch name, so this is the work-around! See: https://stackoverflow.com/questions/13897717/push-commits-to-another-branch/13897766#13897766.

== To *locally* view, review, and compare changes from a GitHub PR, in the (fantastic) "meld" file comparison tool: ==  
Note: despite being able to locally view the changes, you'll still have to use the GitHub interface for all comments and things in the review process. 

A) *Locally* look at changes in meld from a GitHub PR:  <========= VERY USEFUL FOR REVIEWING GITHUB PRs! ===========
1. Set up `meld` as your `git difftool`: https://stackoverflow.com/questions/14821358/git-mergetool-with-meld-on-windows/48979939#48979939
2. See the changes in meld as your `git difftool`:
    git fetch --all
    git checkout origin/branch_from_github_PR
    # This allows you to see all changes introduced by this feature branch, as compared to the 
    # original origin/master the author last rebased against or merged into their feature branch!
    git difftool $(git merge-base origin/master HEAD)   <========= VERY USEFUL FOR REVIEWING GITHUB PRs *in meld*! =========== 
- Optionally, see the *names of files changed* with this:
    git difftool --name-only $(git merge-base origin/master HEAD)
- And the *number of files changed* with this:
    git difftool --name-only $(git merge-base origin/master HEAD) | wc -l
- And the *commit hashes* for all commits that created the feature branch (where I learned about `git cherry`: https://stackoverflow.com/questions/7566416/how-to-see-which-commits-in-one-branch-arent-in-the-other/7566523#7566523; also sort of related (my own ans): https://stackoverflow.com/questions/7566416/how-to-see-which-commits-in-one-branch-arent-in-the-other/60731900#60731900):
    git cherry $(git merge-base origin/master HEAD) HEAD
- And the *commit hashes PLUS commit message subject lines* for all commits that created the feature branch, add `-v`:
    git cherry -v $(git merge-base origin/master HEAD) HEAD
- Why do the `git merge-base` part of the above? Because if you don't, then the `origin/master` that they recently merged into their PR to fix merge conflicts may NOT be the same `origin/master` you just pulled (yours is *newer*). If your `origin/master` you just pulled contains a bunch of newly-landed PRs from other people working simultaneously, for instance, then doing `git difftool master` alone, or `git difftool origin/master`, will be IN THE FUTURE, and you'll be `git diff`ing against FUTURE CHANGES that the PR in question doesn't even know about! Therefore, instead of seeing the true 5 or 10 files changed or whatever, you could see hundreds or even thousands of files changed from these future commits which occurred AFTER the PR requester last merged origin/master into their feature branch. 
-- To verify this and get more insight into it, you can manually `git merge origin/master` into their feature branch on your local machine, and then `git difftool origin/master` will work correctly, and so long as you did a `git merge-base origin/master branch_from_github_PR` BEFORE merging the latest origin/master into their feature branch (and copied and saved the output hash for your future reference), `git lg` will allow you to track back to that merge-base (manually search for it in `git lg` with the forward slash tool (/)), and you'll be able to see what's going on in all of the forks and splits and how far into the FUTURE `git difftool origin/master` was looking! 
-- So, to just avoid all this hassle in the first place, just use the `git difftool $(git merge-base origin/master HEAD)` command every time instead!

B) You may also do the comparison withOUT checking out the branch from the PR as follows:
Note: this has the benefit of allowing you to do the comparison withOUT checking out the branch first! This means you can keep open whatever work you currently had open. The downside, of course, is that you can't `git grep`, `grep`, or otherwise search the code base in the modified state, nor use your IDE or editor to explore the changes. Therefore, I highly recommend just doing option A above instead! 
    git fetch origin/branch_from_github_PR  # update your locally-stored remote-tracking branch to origin/branch_from_github_PR
    git difftool $(git merge-base origin/master origin/branch_from_github_PR)

== To move a chunk of commits to a new branch after a merge as though they were squashed instead: == 
See: https://stackoverflow.com/questions/7566416/how-to-see-which-commits-in-one-branch-arent-in-the-other/60731900#60731900

== To compare file changes after a major rebase: == 
0. Back up your branch and do the rebase onto latest master (this is overly-simplified, but makes the general point):
    git branch mybranch_bak     # make a backup copy of mybranch called mybranch_bak *before* doing the rebase, just in case you mess up the rebase!
    git rebase -i master        # rebase mybranch onto latest master
1. Figure out which files mybranch_bak changed:
    MERGE_BASE=$(git merge-base master mybranch_bak) && git diff --name-only $MERGE_BASE..mybranch_bak > file_list.txt
2. Now look at any changes, ***in just these files**, between your rebased branch and your backed-up branch, to see how your rebase you just did affected these files you previously had worked in and changed: 
    git checkout mybranch       # Ensure you are in your branch you just rebased
    git difftool branch_bak $(cat file_list.txt)    # Look at the files of interest to see how the rebase affected them; ensure no errors exist or were introduced in the rebase!
[THIS SINGLE-LINE CMD IS BROKEN! JUST USE THE 2-STEP CMD SEQUENCE ABOVE FOR NOW INTEAD.] OR, do it all in one single command!
    CHANGED_FILES="$(MERGE_BASE=$(git merge-base master mybranch_bak) && git diff --name-only $MERGE_BASE..mybranch_bak)" && git difftool branch_bak "$CHANGED_FILES"

== patch files / patches ==

Source: https://stackoverflow.com/questions/28192623/create-patch-or-diff-file-from-git-repository-and-apply-it-to-another-different/28193089#28193089
git diff tag1..tag2 > mypatch.patch = produce a patch file with the differences from tag1 to tag2
git apply mypatch.patch = apply all the changes detailed in mypatch.patch
git add -A && git commit = add and commit the changes just applied via the patch command above 
SEE ALSO MY ANSWER HERE ABOUT OBTAINING A PATCH FILE WHICH IS THE EQUIVALENT OF A BIG SQUASH AFTER A MERGE!
  https://stackoverflow.com/questions/7566416/how-to-see-which-commits-in-one-branch-arent-in-the-other/60731900#60731900 
BREAKING UP A BIG DIFF! ^^ See the link to my answer just above!

git branch --edit-description = edit a description of your branch stored in your project's local ".git/config" file; see: https://stackoverflow.com/questions/2108405/branch-descriptions-in-git/8858853#8858853 
See also: https://github.com/bahmutov/git-branches
    git branch --edit-description
    git config branch.master.description "description text"  <=======
    git config branch.master.description
And: https://glebbahmutov.com/blog/git-branches-with-descriptions/#disqus_thread

git clean -fd = WARNING WARNING WARNING THIS IS *DESTRUCTIVE*!!! REMOVE ALL UNTRACKED FILES AND DIRECTORIES; see: https://stackoverflow.com/questions/61212/how-to-remove-local-untracked-files-from-the-current-git-working-tree/64966#64966 

== to delete a branch: == 

There are actually **3 different branches to delete!**. Read more here: https://stackoverflow.com/questions/2003505/how-do-i-delete-a-git-branch-locally-and-remotely/23961231#23961231
1. Deleting a **local branch**:
    git branch --delete <branch>
    git branch -d <branch> # Shorter version
    git branch -D <branch> # Force-delete un-merged branches
2. Deleting a **remote branch**:
    git push --delete origin <branch>  # Git version 1.7.0 or newer
    git push -d origin <branch>        # Shorter version (Git 1.7.0 or newer)
    git push origin :<branch>          # Git versions older than 1.7.0
3. Deleting a **remote-tracking branch**:
    git branch --delete --remotes <remote>/<branch>
    git branch -dr <remote>/<branch> # Shorter <===
    -----
    git fetch --prune <remote> # Delete multiple obsolete remote-tracking branches; ie: "Before fetching, remove any remote-tracking references that no longer exist on the remote."--see `man git fetch` then search for "prune"
    git fetch -p <remote>      # Shorter version of the above

== other: == 

git rev-parse HEAD = obtain the git hash for HEAD; see: https://stackoverflow.com/questions/949314/how-to-retrieve-the-hash-for-the-current-commit-in-git/949391#949391
git rev-parse HEAD~4 = obtain the git hash 4 commits prior to HEAD; this is REALLY USEFUL, for instance, when trying to figure out which commit is N commits back when there have been multiple merges and it's confusing which commit was on which fork of those branches when looking at just `git log`. `git lg`, therefore, becomes much more important and useful as well, as it graphically shows these forks, branches, and merges in tree form!

git checkout -- my_file.txt = [WARNING: DESTRUCTIVE OF LOCAL COPY!] check out my_file.txt from HEAD and make it overwrite the current local copy I have! Good for "reverting" local, uncommitted changes on a file or two you're working on and messed up.

git diff --name-only <commit_hash1>..<commit_hash2> | wc -l = see how many files were changed between commit_hash1 and commit_hash2


====================================================================================================
= grep: = 
====================================================================================================

*****See my own answer here, for instance, for `grep` & `git grep` examples: https://stackoverflow.com/questions/60843047/locating-a-function-in-a-git-repository/60843055#60843055

== Exlude a word: == 
Use the `-v`, or `--invert-match` option! See:
1. https://stackoverflow.com/questions/4538253/how-can-i-exclude-one-word-with-grep/4538335#4538335
1. https://stackoverflow.com/questions/10411616/grep-regex-not-containing-string/10411661#10411661
    grep "pattern_to_find" file | grep -v "pattern_to_exclude" = search for "pattern_to_find" while EXCLUDING (in'v'erting the match on) "pattern_to_exclude"  <==== EXCLUDE WORD(S) WHEN GREP-SEARCHING! =====
OR
    grep -v "unwanted_word" file | grep "wanted_word" = same as above, just in the opposite order is all.

Here's some examples. This outputs "redhat" and "yellowtail":
    $ echo "redhat redwood redbox redding yellowtail" | grep -E -o "(redhat|yellowtail)"
    redhat
    yellowtail
So this outputs just "yellowtail", by then excluding anything with "red" in it!:
    $ echo "redhat redwood redbox redding yellowtail" | grep -E -o "(redhat|yellowtail)" | grep -v red
    yellowtail

find -type f | grep -v \.xml | xargs grep --color=always my_regex_search = find only 'f'iles (no directories) which do NOT end in .xml, then search each of those files to see if they contain "my_regex_search" <====== VERY USEFUL! =======


====================================================================================================
= Jinja2: = 
====================================================================================================

- a template-based automatic code/file generator (think string formatter/replacer for an entire text file).

Main Jinja2 References:
1. [Main Jinja2 website](https://jinja.palletsprojects.com/en/2.11.x/)
2. [Entire Jinja2 documentation in PDF form](https://jinja.palletsprojects.com/_/downloads/en/2.11.x/pdf/)
3. [Jinja2 Python API](https://jinja.palletsprojects.com/en/2.11.x/api/)
4. [Jinja2 Template Designer (used for writing template files, which some people like to end in .j2)](https://jinja.palletsprojects.com/en/2.11.x/templates/)


====================================================================================================
= Linux (General): = 
====================================================================================================

w = "Show who is logged on and what they are doing"; great command to ensure you're the only one remotely logged on to a PC, for instance!

== Limit CPU usage: == 
[throttle cpu usage]
Limit CPU usage of a process in Linux: https://linoxide.com/linux-how-to/limit-cpu-usage-processes-linux/; ex:
    cpulimit -p 3185 -l 40 = limit Process ID (PID) 3185 to 40% ***of 1 CPU*** max CPU usage; so, for a multi-core machine (ex: 8 cores), to get a total of 40% of all cores you would need to use 0.4*(100/core * 8 cores) = 0.4*800 = 320, like this:
    cpulimit -p 3185 -l 320 = limit PID 3185 to 320% out of 800% (on an 8-core machine) = 320/800 = 40% overall on an 8-core machine!
OR
    cpulimit -e vmware-vmx -l 40 = limit the process named "vmware-vmx" to 40% ***of 1 CPU*** max CPU usage
    cpulimit -e vmware-vmx -l 320 = limit PID 3185 to 320% out of 800% (on an 8-core machine) = 320/800 = 40% overall on an 8-core machine!
So, to limit to 80% on an 8-core machine, use 0.8*800 = 640, like this:
    cpulimit -p 3185 -l 640
Limit to 62.5% on an 8-core machine:
    cpulimit -p 3185 -l 500

This is very useful to limit your CPU usage being used by Bazel, for instance, when it is building for dozens of minutes, or even hours.Â Note that the Bazel build server JVM is usually just called "java", and can easily be viewed with `ps`, `top`, `htop`, or the `gnome-system-monitor` GUI (my preferred choice).

    sudo apt update
    sudo apt install cpulimit
    # Start your bazel build in one terminal, then in a separate terminal, run the following.
    # Replace <pid> with the Process ID number for your bazel build server process (usually
    # just called "java" when you look at it with `ps`, `top`, `htop`, or `gnome-system-monitor`).
    cpulimit -p <pid> -l 500 # limit your bazel build to 62.5% max CPU usage on an 8-core machine <=====

Leave the `cpulimit` process running as long as you want this limiting effect in place. You don't need to restart it each time you begin a new bazel build, as the bazel build server continues running in the background even after a build completes.

== Mosh: ==
An ssh-replacement program for better connections over wifi, cellular, and long-distance links. It is free software (GNU GPLv3)!
It can decrease response time by a factor of 30~50 on lossy networks (see Wikipedia article below)! Ex: 16.8 seconds response time --> 0.33 seconds, or 5.9 --> 0.19 sec.

References:
1. https://mosh.org/#getting
2. https://en.wikipedia.org/wiki/Mosh_(software)

== Find files and replace text in files: ==

find -type f = recursively find only files (NOT directories)

find | grep "my_file" = find any file with "my_file" in its name
find -L | grep "my_file" = same as above, but also follow symbolic links when searching

find | grep ".*\.txt$" = find any file which MUST END WITH .txt (the $ searches for an "end of line" character to ensure what's just before it is only at the very end of a string)

find | grep -E ".*(\.ino|\.cpp|\.c|\.h|\.hpp|\.hh)" = find any file with one of these extensions

sed -i "s|regex_pattern_to_match|replacement_string|g" my_file.txt = 'g'lobally replace (ie: replace all matching occurrences) of "regex_pattern_to_match" 'i'n place in my_file.txt, replacing the matching pattern with "replacement_string"

PUTTING IT ALL TOGETHER:
References:
1. https://linuxize.com/post/how-to-use-sed-to-find-and-replace-string-in-files/
1. https://unix.stackexchange.com/questions/159367/using-sed-to-find-and-replace/159369#159369 (also see my comment under this answer!)
1. *****https://stackoverflow.com/questions/10445934/change-multiple-files/30717770#30717770
1. *****Really good sed reference! https://www.grymoire.com/Unix/Sed.html

find some/path -type f | grep -E ".*(\.ino|\.cpp)" | xargs sed -i "s|regex_pattern|replacement_string|g" = find all files in some/path which end in .ino or .cpp and pipe them to sed. sed will then find and replace all matches of "regex_pattern" with "replacement_string" in these files. <======= BEST NON-WHOLE-WORD MULTI-FILE SEARCH & REPLACE =====
EXAMPLE:
find src/arduino -type f | grep -E ".*" | xargs sed -i "s|printf|sprintf|g"

To match whole words, use the regex `\b` word boundaries!
- See: https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch02s06.html
find some/path -type f | grep -E ".*(\.ino|\.cpp)" | xargs sed -i "s|\bregex_pattern\b|replacement_string|g" = same as above, except with `\b` `\b` to make it a whole word search! <======= BEST WHOLE-WORD MULTI-FILE SEARCH & REPLACE =====
EXAMPLE:
find src/arduino -type f | grep -E ".*" | xargs sed -i "s|\bprintf\b|sprintf|g"

== wc: == 
wc = 'w'ord 'c'ount

find | wc -l = count and return the number of 'l'ines returned by find, which corresponds to the number of files and folders in a directory and its sub-directories.

== tr: ==
<your_command> | tr -d ',' = remove all commas from the output of `your_command`; see: https://stackoverflow.com/questions/12668020/removing-characters-from-grep-output/12668078#12668078

